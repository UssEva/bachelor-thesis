% !TeX spellcheck = en_GB
% !TeX encoding = UTF-8
% !TeX root = ../thesis.tex
\chapter{Introduction}\label{chap:introduction}
%TODO Unfinished chapter!

As one of the most popular block-based programming languages \scratch{}~\cite{scratch} has established a growing community over the years that surrounds a database of almost 60 million created projects\footnote{\url{https://scratch.mit.edu/statistics/}, last accessed September 01, 2020}. Because of the fun and easy programming environment that supports novice programmers particularly in their creative process, \scratch{} is preferred by students over text-based languages when it comes to studying about the world of programming. The drag-and-drop principle of puzzle pieces helps beginners to avoid common syntax mistakes and encourages children in a fun way to take control over the \textit{stages} and \textit{sprites} and create their own world and stories. Memorization instead of recall is an important part of the \scratch{} system because by picking your favourite blocks from a palette instead of having to know all commands right away is helping programming novices to get fast and viewable results. 

Though \scratch{} makes programming seem easy, there are also many mistakes that programmers can commit if they are unaware of common programming practices. The frustration of finding these bugs in a huge amount of code blocks is even more apparent as a teacher who has to examine each project manually because of missing tools in the \scratch{} editor that usually are a part of every standard programming frameworks, like Intellij\footnote{\url{https://www.jetbrains.com/idea/}, last accessed September 01, 2020} or Eclipse\footnote{\url{https://www.eclipse.org/}, last accessed September 01, 2020}. In order to support \scratch{} users and improve their code quality and accuracy, there are many researchers who find methods to detect bug patterns~\cite{scratch_bugpatterns} as well as code smells~\cite{badsmells, badhabits, hairball} or even implemented automated approaches for testing~\cite{whisker} for the \scratch{} environment. As a result, tools like \hairball~\cite{hairball}, \drscratch~\cite{drscratch} or \litterbox~\cite{scratch_bugpatterns} were created to further the analysis of \scratch{} programs and assist programmers in their bug detection process.

In order to improve code quality and reliability of programs, many rule-based techniques have been researched to detect bugs and code smells. However, these rule-based approaches are relying on highly frequent patterns in the code. Another approach is the usage of \ngram{s} for code analysis. This way of detecting defective code is already successfully applied by \bugram{}~\cite{bugram} on \java{} code. The assumption is that low probability token sequences are unusual, which may indicate bugs, bad practices or special uses of code. 

The \ngram{} works by assessing token sequences of programs by their probability in the learned model while low probability ones are marked as bugs. For bug detection the five main components that need to be configured for the model are: \textit{Gram size, sequence length, reporting size, maximum probability threshold} and \textit{minimum token occurrence}. After adjusting these settings, the n-gram Markov model is able to obtain the probabilities of all token sequences. The probability of each token in a sequence is only determined by its previous n-1 tokens. Using a 3-gram model the probability of the sequence s is calculated like it is shown in the Equation~\ref{eq:sequence_prob}. Then the language model ranks the outcome based on its probability in descending order and reports the sequences with the lowest probabilities as potential bugs. 
 
\begin{equation} \label{eq:sequence_prob}
P(s) ={} P(b_{1})\cdot P(b_{2}\mid b_{1})\cdot P(b_{3}\mid b_{1}b_{2})\cdot P(b_{4}\mid b_{2}b_{3})
\end{equation}

%TODO My contribution 
In this bachelor's thesis a technique that uses \ngram{s} to automatically detect bugs in \scratch{} programs is proposed. 

%TODO Evaluation